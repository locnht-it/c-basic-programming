===================================================================================
I. BIẾN/VARIABLE

1. Biến là gì? Biến được lưu trữ trong RAM như thế nào?
file:///D:/SoftwareEngineer/C/c-craftsman-main/atlas/[giao.lang]%20C%20Atlas-22.0111.pdf

2. Các loại biến

* Biến tại 1 thời điểm chỉ lưu 1 value.

* Biến có thể nằm ngoài tất cả các hàm: BIẾN TOÀN CỤC - GLOBAL VARIABLE. Hàm nào cũng có thể thay đổi value của biến.
  
* Biến có thể nằm trong hàm, trên tên hàm, trong vòng lặp - BIẾN CỤC BỘ - LOCAL VARIABLE
  - Biến nằm trên tên hàm còn gọi là đầu vào, tham số hàm/parameter, argument.
  - Biến nằm trong hàm.
  - Biến nằm tít trong vòng for, while -> siêu cục bộ

* BIẾN LOCAL TRÙNG TÊN BIẾN GLOBAL -> CĂNG À NHEN, ƯU TIÊN BIẾN CỤC BỘ!!!
  Hiện tượng che biến/hide a variable. Em có cũng như ko!!! Ko thấy em!!!


===================================================================================
II. GARBAGE VALUE
- Xin biến/xin đất/mua đất/declare a variable mà ko gán value, thì vùng RAM cấp sẵn này trước đó có thể có value on off của app khác trước đó để lại, nếu mình in value của biến này thì ta sẽ có giá trị vớ vẩn nào đó, được gọi là GARBAGE VALUE. 
- Nguy hiểm cho app vì app xử lí sai.

===================================================================================
III. HÌNH DÁNG/HÌNH THÁI DỮ LIỆU - CÁCH THẤY/DỮ LIỆU CÓ DẠNG NHƯ THẾ NÀO - DATA TYPES

1. SỐ *

 a. Nguyên

  - Nhỏ: byte (-2^7 -> 2^7 - 1 | 0 ... 255)

  - Vừa: int (-2^31 -> 2^31 - 1 | - 2 tỉ 1 -> 2 tỉ 1 - 1 )
	
  - Bự: long (-2^63 -> 2^63 - 1)

 b. Thực

  - Vừa: float (+- 10^38)

  - Bự: double (+- 10^308)

----------------------------------------------------------------------------------
- Kiểu dữ liệu byte, int, long, float, double, char là những thứ cơ bản để ta tính toán xử lí.
- Khi ta xác định loại data ta cần lưu trữ, lập tức CPU sẽ cấp ngay 1 số byte tương ứng!!!

	byte, 	int, 	long, 	float, 	double, 	char 
	 1	 4 	 4-8 	 4 	 8 		 1

- IN RA, LẠI PHẢI DẠY CHO MÁY CÁCH NÓ IN RA, DÙNG KÍ HIỆU % DẠY NÓ IN RA MÀN HÌNH.
- NHẬP TỪ BÀN PHÍM, LẠI PHẢI DẠY CHO MÁY CÁCH NÓ ĐƯA DATA TỪ BÀN PHÍM VÀO RAM VÀ ON-OFF TƯƠNG ỨNG, DÙNG KÍ HIỆU % DẠY NÓ CÁCH CONVERT BÀN PHÍM THÀNH 010101.

- % ĐƯỢC GỌI LÀ ĐỊNH DẠNG DATA, FORMAT OF DATA, ÉP DATA PHẢI THÀNH CÁI GÌ, TRONG RAM TOÀN ON-OFF.

	byte, 	int, 	long, 	float, 	double, 	char 
	 1	 4 	 4-8 	 4 	 8 		 1
		 %d	 %ld	 %f	 %lf		 %c

	d: decimal
	ld: long decimal
	f: float
	lf: long float

- LỆNH PRINTF() HOẠT ĐỘNG THEO CÁCH ĐIỀN VÀO CHỖ TRỐNG.

- MỖI KIỂU DỮ LIỆU CÓ MIỀN GIÁ TRỊ MIN - MAX.

-----------------------------------------------------------------------------------
C HỖ TRỢ CÁC PHÉP TOÁN ĐỂ TÍNH TRÊN CON SỐ, Y CHANG NGOÀI ĐỜI.
- OPERATOR (phép toán) + - * /	%: chia lấy số dư
		       cần 2 toán hạng/số hạng/OPERAND

- MỘT NGÔI/1 BIẾN ĐÃ TÍNH ĐC RỒI, KO CẦN 2 VẾ 2 BÊN
  ++ --
  ko có khái niệm ** //
  ++bien; bien++ sau lệnh này biến sẽ đc tăng lên 1 đơn vị.
  Tuy nhiên lệnh khá cà chớn khi lắp ghép chung với các biểu thức khác.
  NẾU BIẾN++; ++BIẾN ĐỨNG 1 MÌNH THÌ ++ ĐỨNG TRƯỚC SAU KO ẢNH HƯỞNG KẾT QUẢ, ĐỀU
  TĂNG LÊN 1.
  NHƯNG KHI ĐƯA ++ VÀO TRONG BIỂU THỨC, KẾT QUẢ SẼ VI DIỆU KHI ++ ĐỨNG TRƯỚC HOẶC 
  SAU!!!

  CHỐT HẠ: ĐỪNG VIẾT CODE KIỂU MƠ HỒ (int r = ++n;), ko nên chơi gộp nếu bạn ko
  hiểu hay ko kiểm soát đc value. Cần xác định tính trước hay gán trước:
	n++;
	r = n;

	r = n;
	n++;
  
- Nhồi (có rồi, ép thêm vô):
	+=	-=	*=	/=	%=

  Muốn tăng lên 1 lượng nhất định, ta dùng toán tử nhồi tự thân
  Vd: m *= 8; ~~ m = m * 8;

NGUYÊN CHƠI VỚI NGUYÊN -> CHỈ RA NGUYÊN.
THỰC CHƠI VỚI ĐỨA NÀO CŨNG LÀ THỰC.

-----------------------------------------------------------------------------------
CÁCH LƯU SỐ NGUYÊN DƯƠNG VÀ ÂM TRONG MÁY TÍNH - KĨ THUẬT SỐ BÙ 2 - TWO'S COMPLEMENT
* Dùng 1 số bit nhất định để lưu 1 con số nguyên (+ -)
  32 bit/4 byte để lưu con số nguyên int (-2 tỷ 1 -> 2 tỷ 1).

* Biểu diễn + - như thế nào? Người ta trích ra, dùng bit bên trái nhất gọi là bit dấu - sign bit, quy ước bit này là 0 -> số dương
				   1 -> số âm
  bị hụt mất 1 bit để biểu diễn giá trị
  int chiếm 32 bit, dùng 31 bit để biểu diễn giá trị + -, còn bit 32 dùng làm dấu

 Ví dụ: tui xài 4 bit để lưu số nguyên, túm lại ta lưu đc con số nguyên bự cỡ nào, nhỏ cỡ nào?
  	0 000	số dương
	0 001
	0 010
	1 011	số âm
	...

* Nguyên tắc biểu diễn số nguyên +
 - bit dấu (bit trái ngoài cùng phải là 0)
 - phần bit còn lại biểu diễn đại lượng số - dùng thuật toán đổi nhị phân sang thập phân mà tính!!!
	0 000 -> dương mấy? dương 0
	0 001 ->		  1
	0 010 ->		 +2
	0 011 ->		 +3

	  210 -> 2 mũ
	0 010 = 0.2^0 + 1.2^1 + 0.2^2 = 2
	
	  210 -> 2 mũ
	0 011 = 1.2^0 + 1.2^1 + 0.2^2 = 3

* Biểu diễn số âm như thế nào??? 
 - NÊN CĂN TỪ SỐ DƯƠNG MÀ CHƠI
 - DÙNG KĨ THUẬT BÙ 2: TỪ DƯƠNG SUY RA ÂM, 
		       TỰ NÓ KHIẾN CHO BIT TRÁI CÙNG THÀNH 1 - ÂM
 
 Vd: 1 001 -> HỎI THẦY ÂM MẤY??? CHƯA TRẢ LỜI NGAY ĐC, KO NHƯ TRẢ LỜI SỐ +

     0 011 ->	+3
     HỎI ÂM 3 LÀ SỐ MẤY?
     đứa nào muốn mất điểm, ghi đáp án: 1 011 ??? SAI
  
 - BÙ 2 TỪ SỐ DƯƠNG BẮT ĐẦU:
  + Đảo toàn bộ bit của con số +
  + Cộng kết quả đảo với con số 1
  -> kết quả phép cộng chính là số ÂM cần tìm.
  
  Vd: 0 011 -> +3
      - ĐẢO BIT: 1 100
      - CỘNG 1:      1
		  ----
		 1 101 -> -3 (BÙ ĐẮP EM 2 NHÁT, NHÁT 1 ĐẢO BIT, + 1)
  Chứng minh 1 101 là âm 3:
	-3 + +3 = 0!!!

	0 011	+3
	1 101	-3
	-----   --
     1  0 000	 0

  - NẾU CÓ ÂM, SUY RA DƯƠNG THÌ SAO? VẪN BÙ 2 MÀ CHƠI
	
	1 101	(biết trước là -3), nhưng giả bộ ko biết, túm lại là âm mấy
	-> trả lời = cách đi tìm dương
	-> Đảo bit: 
	1 101 -> 0 010
	-> + 1:	     1
		-------
		 0 011 -> +3

* Nếu ta xài 4 bit để biểu diễn con số dương hoặc âm
  Vd: 0 111 -> là con số mấy -> +7 ngoài đời, to nhất khi chơi 4 bit

  4 bit để biểu diễn chỉ con số +, ko care số âm, hỏi số bự nhất là số mấy?
  -> 1111 -> 15 ngoài đời
  -> Chỉ quan tâm +, ko dùng bit dấu, thì cứ thuật toán đổi nhị phân mà chơi!!!

  3210 -> 2 mũ
  1111 -> 15 
  
  xài hết bit để chỉ biểu diễn số +, số + này mang tên un-signed.
 		
-----------------------------------------------------------------------------------
2. KÍ TỰ *

- Mỗi kí tự đc chống lưng/đc ánh xạ thành 1 con số 0...255 (tổ hợp/số cách ghép
  của 2^8 = số cách ghép của 0101 của 8 bit)

BIOS/UEFI
Bảng mã ASCII,	0, 1, 2, 3, 4 ... 255 (quan điểm hệ 10) gọi là mã ASCII
giống mã số sinh viên đại diện cho mình
      mã số ASCII     đại diện cho kí tự
American Standard Code for Information Interchange
Lúc đầu xài 7 bit, sau này mở rộng 8 bit

Value trong RAM	    Mã ASCII	 Kí hiệu	

00000000		0	  '\0'
00000001		1
00000010		2
00000011		3
00000100		4
00000101		5
00000110		6
00000111		7
...
			32	-> khoảng trắng
			48	   '0'
			49	   '1'
		
			65	   'A'
			66	   'B'

			97	   'a'
...

11111111	255	0 -> 255  = 256 = 2^8

- Mỗi kí tự có thể chơi theo 2 cách:
 + Chơi theo cách truyền thống		char firstChar = 'L';
 + Chơi theo mã số chống lưng		char firstChar = 76;

 * char firstLetter = 234;
   //char ~~~ số nguyên 1 byte!!!, số có dấu 1 byte

   %c -> lấy tất cả các bit convert thành số +, map vào bảng mã ASCII, tìm ra Omega
   %d -> hiểu là số nguyên, thì chỉ lấy 7 bit giá trị, trừ bit đầu dành cho dấu,
	 ko đủ 234 như bình thường, và hiển thị số lạ.
   char firstLetter = 234; // 1110 1010 
   %c	-> xài full bit, convert thành 234 -> map ASCII thấy Omega
   %d	-> loại bit đầu ra, phần còn lại value mấy???
	   1 110 1010 âm mấy???		-22
	
   bù 2, đảo bit	0 001 0101
	 cộng 1		         1
	 		----------
			0 001 0110 -> + mấy
			    4 3210 -> 2 mũ
			    2^4 + 2^2 + 2^1 = 22

   tui muốn %c dĩ nhiên chạy đúng, %d chạy đúng luôn
   -> xài đủ 234, đủ 234 tức là chơi ko dấu. 
   -> unsigned char firstLetter = 234;	

   char firstLetter = 128;    %c xài hết bit, 128 -> C map qua ASCII
	
	    1000 0000	      %d xài bit dấu, 1 số âm rồi đó, âm mấy thì phải bù 2
   đảo bit: 0111 1111
   cộng 1:          1
             --------
            1000 0000	-> 128  

- NHẬP KÍ TỰ TỪ BÀN PHÍM
	char bien;
	scan("%c", &bien);

 + Kiểu kí tự rất đặc biệt, vì nó có những kí tự ẩn: omega, điều khiển(enter) xóa,
   tab, xuống hàng -> khi nhập kí tự từ bàn phím sẽ bị hiện tượng lệnh lạc trôi -  
   by passed a statement, dính đến khái niệm bộ đệm bàn phím BUFFER (NOT BUFFET) ->
   bắt buộc trước lệnh scanf(%c) PHẢI CÓ LỆNH XÓA BỘ ĐỆM BÀN PHÍM

	fflush(stdin);		//MAC: fpurge(stdin);	Linux __fpurge(stdin);
	scanf(%c);

 * BUFFER - BỘ ĐỆM BÀN PHÍM (KO PHẢI BUFFET)
   
   LIÊN QUAN ĐẾN VIỆC NHẬP DỮ LIỆU TỪ BÀN PHÍM

   HIỆN TƯỢNG LỆNH LẠC TRÔI/CẢM GIÁC NHƯ CÓ LỆNH NÀO ĐÓ HOK CHẠY - BY PASS A STATEMENT

   CHỈ XẢY RA KHI???
   NHẬP KÍ TỰ/CHUỖI - câu dài (chưa học) SAU NHẬP SỐ!!!
   DO LỆNH NHẬP SỐ CHƠI ĐỂU, NÓ ĐỂ LẠI RÁC ENTER TRONG VÙNG RAM ĐẶC BIỆT GỌI LÀ BUFFER
   HOẶC XẢY RA KHI CÓ 2 LỆNH NHẬP CHỮ/CHUỖI LIỀN NHAU
   NÓI CHUNG, LỆNH scanf(%c %s) nó chỉ thích đứng 1 mình ko bị sao cả

- XEM LẠI BẢNG MÃ ASCII
  + DÙNG 8 BIT MÃ HÓA CÁC KÍ TỰ, NHỮNG THỨ TA VẼ RA BIỂU THỊ 1 CÁI GÌ ĐÓ
	A -> chữ cái a hoa	65 (dec)
	a -> chữ cái a thường	97 (dec) -> hoa nhỏ hơn thường 32 đơn vị!!!

  + Muốn đổi hoa sang thường hay ngược lại, ta đổi mã ASCII, hoặc lấy mã ASCII +- 32

	0 -> chữ 0, vẽ ra hình tròn tròn, biểu thị thêm đại lượng
	'0'		48
	'1'		49

	dấu cách	32
	
  + Có những kí tự, ko hiển thị rõ ràng cho mình xem, nhưng thực sự có tồn tại!!!
   Vd: xóa 1 chữ nào đó - backspace
       xuống hàng là 1 kí tự, vì nó có hiển thị kiểu nào đó khiến cho câu thơ ngắt làm 2.
   Đối với Windows, khi nhấn Enter, sinh ra 2 tín hiệu, về đầu dòng: CR Carriage Return
							 giựt xuống dòng LF Line Feed
	Linux, MAC	....			      xuống hàng phải về đầu dòng, LF là đủ

   xuống hàng ko xuất hiện rõ ràng trên màn hình, nhưng nó có tồn tại
   vậy vẫn cần 1 cái gì đó để nói về cái kí tự xuống hàng, xóa, vô hình mà tồn tại
   những kí tự vô hình, vẫn tồn tại cho nhu cần soạn thảo, vậy thì sẽ đc kí hiệu theo 1 quy ước riêng:
	'\n'	LF kí hiệu cho xuống hàng
	'\r'	CR kí hiệu cho việc về đầu hàng
	'\b'	backspace đó, xóa kí tự heng
	'\t'	tab	
  
  + CÓ 1 KÍ TỰ CỰC KÌ QUAN TRỌNG, NÓ CŨNG VÔ HÌNH, NHƯNG NÓ CẦN TỒN TẠI ĐỂ ĐÁNH DẤU 1 CÁI GÌ ĐÓ!!!

    KÍ TỰ MANG MÃ SỐ SINH VIÊN LÀ 0, MÃ ASCII 0, 8 BIT LÀ 0000 0000
	       MÃ ASCII/ASCII CODE

0000 0000 -> 0	  '\0'	1 KÍ TỰ VÔ HÌNH SIÊU QUAN TRỌNG - NULL VÔ THƯỜNG, VÔ HÌNH
			dùng như cái flag đánh dấu 1 điều gì đó trong RAM
			trên HDD/SSD, ví dụ dùng để đánh dấu kết thúc chuỗi 
			trong RAM.
			

0000 1001 -> 9	  '\t'	1 KÍ TỰ VÔ HÌNH, TAB ĐÓ
0000 1010 -> 10	  '\n'	1 KÍ TỰ VÔ HÌNH, XUỐNG HÀNG ĐÓ

...	  -> 32   ' '	1 KÍ TỰ VÔ HÌNH, DẤU CÁCH ĐÓ


Vd: nhà cậu có 1 con bò, mày có 100 con bò, bạn mày có 1000 con bò
    nhà tao éo có con bò nào??? DÙNG CÁI GÌ, KÍ HIỆU GÌ ĐỂ BIỂU DIỄN KO GÌ CẢ
    có 1 cái gì đó để nói về 0 gì cả -> số 0 ra đời
	

3. ẢNH

4. PHIM

5. ÂM NHẠC

6. DOCUMENT

...

===================================================================================
IV. SO SÁNH

- BÀN VỀ SO SÁNH, SO SÁNH DÙNG ĐỂ ƯỚC LƯỢNG HƠN THUA CỦA CÁC ĐẠI LƯỢNG SỐ  
- C CUNG CẤP 1 LOẠT KÍ HIỆU/TOÁN TỬ DÙNG ĐỂ SO SÁNH CÁC ĐẠI LƯỢNG GIỐNG BÊN TOÁN HỌC GIÚP TA XÂY DỰNG CÁC BIỂU THỨC TÍNH TOÁN/MỆNH ĐỀ/CÂU PHÁT BIỂU:

>	coi vế trái có lớn hơn vế phải hem>
	
>=	coi vế trái có lớn hơn vế phải hem? nếu ko, thì coi tiếp trái có bằng phải 
	hem? chỉ cần 1 trong 2 là đủ: lớn hơn hay/hoặc bằng

<

<=

==	vì dấu = đứng một mình, đã lỡ được dùng để gán giá trị (assign operator)
	nên ta muốn so sánh hay nói rằng 2 thứ = nhau, thì phải dùng kí hiệu khác
	để tránh máy bối rối, người cũng thế, ta dùng đến == để nói rằng trái bằng
	phải đó!!!

!=	để nói rằng 2 đứa khác nhau, chỉ 1 dấu = vì có thêm ! nghĩa là phủ định

- KẾT QUẢ CỦA 1 BIỂU THỨC SO SÁNH/PHÉP SO SÁNH LÀ ĐÚNG SAI
5 > 6: SAI
6 > 6: SAI
6 > 5: ĐÚNG

6 >= 6: ĐÚNG, VÌ CHỈ CẦN 1 TRONG 2 ỔN, TẤT CẢ ỔN
6 >= 7: SAI

6 == 6: ĐÚNG

6 != 6: SAI

100 < 100: SAI

100 != 5: ĐÚNG
 
100 == 100: ĐÚNG

-> MỘT BIỂU THỨC SO SÁNH SẼ MANG 1 TRONG 2 GIÁ TRỊ ĐÚNG/SAI
   C QUY ƯỚC ĐÚNG : 1
	     SAI  : 0
   MỘT BIỂU THỨC SO SÁNH TÙY ĐÚNG SAI THÌ SẼ MANG 1 TRONG 2 GIÁ TRỊ 0 1
   DO ĐÓ TA GỌI LÀ BIỂU THỨC SO SÁNH ~~ 1 GIÁ TRỊ DO ĐÓ TA GÁN ĐC BIỂU THỨC SO SÁNH
   VÀO 1 BIẾN INT

   int result = 5 > 6; 	ngoài đời nói sai
			C, CPU nói rằng result là con số 0

===================================================================================
V. MỆNH ĐỀ LOGIC - SỰ KẾT NỐI GIỮA CÁC BIỂU THỨC ĐÚNG SAI

Má dặn Con lên SG học
Lên SG học tốt nha Con

	Ko đổi chuyên ngành
	Điểm tb >= 8
	Ko đc rớt môn nào trong quá trình học		AND: PHỤ THUỘC CHẶT CHẼ 
	9 kì là phải học xong				GIỮA CÁC MỆNH ĐỀ/CÂU PHÁT
							BIỂU
all of above, tất cả phải đúng như thế

C CUNG CẤP KÍ HIỆU/TOÁN TỬ ĐỂ KẾT NỐI CÁC CÂU PHÁT BIỂU, MỆNH ĐỀ SO SÁNH/STATEMENT ĐỂ CHO RA 1 KẾT QUẢ ĐÚNG SAI CUỐI CÙNG:

&&	cực kì chặt chẽ giữa các mệnh đề
	NẾU CHIỀU NAY TRỜI NẮNG VÀ TIỀN RỦNG RỈNH, CHÚNG MÌNH NHẬU	
	NẾU CHIỀU NAY TRỜI NẮNG, HOẶC TIỀN RỦNG RỈNH, MÌNH NHẬU

||	lỏng lẻo hoy,
	Hoặc tao, hoặc mày phải ghé thăm em í
	Tao và mày ghé thăm em í

!	nghịch đảo, làm ngược lại, tương phản

Vd: Cho tuổi của bạn là 1 con số nguyên. Hỏi tuổi có nằm trong đoạn thanh xuân hay ko? [20...30]

* CÁCH SUY LUẬN KẾT QUẢ CỦA 1 BIỂU THỨC PHỨC TẠP GỒM LỘN XỘN AND/OR:
 - TỨC LÀ 1 CÂU PHÁT BIỂU BÊN TRONG CÓ CÁC BIỂU THỨC SO SÁNH, NỐI VỚI NHAU = && || 
   VẬY KẾT QUẨ CHUNG CUỘC CỦA CÂU NÀY LÀ ĐÚNG HAY SAI??? VÌ MỖI PHÉP SO SÁNH LUÔN
   LÀ ĐÚNG HOẶC SAI

 - TA CẦN 1 QUY TẮC ĐỂ TÌM NHANH KẾT QUẢ GIỮA 1 ĐỐNG AND OR
   BỘ QUY TẮC NÀY ĐÃ ĐC VIẾT RA, TA CHỈ CẦN THEO, ĐEM QUY TẮC NÀY VÀO TRONG MÁY 
   TÍNH, BỘ QUY TẮC NÀY GỌI LÀ BẢNG SỰ THẬT, BẢNG CHÂN TRỊ, TRUTH TABLE:

  + &&

MỆNH ĐỀ		PHÉP TOÁN		MỆNH ĐỀ		KẾT QUẢ
   A		  &&			  B		ĐÚNG/SAI
	A, B BẢN THÂN LÀ 1 > < >= <= == !=
  SAI		  &&			  SAI		  SAI
  SAI		  &&			  ĐÚNG		  SAI
  ĐÚNG		  &&			  SAI		  SAI
  ĐÚNG		  &&			  ĐÚNG		  ĐÚNG

Chốt hạ toán &&: Biểu thức && CHỈ ĐÚNG NẾU TẤT CẢ ĐỀU ĐÚNG
	 	 Một thằng sai, toang cả đám - SAI

	Vd: 	age >= 20 && age <= 30
		age = 25 -> thanh xuân
		age = 31 -> ngoài!!!

  + ||

MỆNH ĐỀ		PHÉP TOÁN		MỆNH ĐỀ		KẾT QUẢ
   A		  ||			  B		ĐÚNG/SAI
	A, B BẢN THÂN LÀ 1 > < >= <= == !=
  SAI		  ||			  SAI		  SAI
  SAI		  ||			  ĐÚNG		  ĐÚNG
  ĐÚNG		  ||			  SAI		  ĐÚNG
  ĐÚNG		  ||			  ĐÚNG		  ĐÚNG

Chốt hạ toán ||: BIỂU THỨC CHỈ CẦN 1 THẰNG ĐÚNG LÀ ĐỦ, ĐÚNG
				CẢ 2 ĐÚNG CÀNG TỐT
		 OR sai khi tất cả cùng sai
	
	Vd:	Hoặc tớ hoặc cậu ghé thăm cô ấy!!! -> Cần tối thiểu

  + ! 
	!(đúng) -> sai
	!(sai)  -> đúng

	Vd: !(x < 1 || x > 100) ngược lại của ngoài miền -> trong miền

===================================================================================
VI. ĐIỀU HƯỚNG CPU THỰC THI CÁC CÂU LỆNH - LOGIC CONSTRUCTS/IF-FOR-DO/WHILE

 1. CÂU LỆNH RẼ NHÁNH 

* MẶC ĐỊNH, CPU CHẠY CÁC LỆNH TỪ TRÊN XUỐNG DƯỚI, SEQUENCIAL ORDER/SEQUENCE CONSTRUCT.
-> CPU ĐI ĐẠI LỘ, ĐƯỜNG THẲNG.

* SELECTION CONSTRUCT/RẼ NHÁNH, BẮT CPU QUẸO HẺM, RỒI SAU ĐÓ LẠI RA ĐƯỜNG LỚN.
  CPU KO CẦN THIẾT PHẢI THỰC THI HẾT CÁC LỆNH, CÓ NHỮNG LỆNH, SẼ ĐC LÀM 1 LÚC NÀO,
  DƯỚI 1 TÌNH HUỐNG NÀO ĐÓ, 1 ĐIỀU KIỆN NÀO ĐÓ.
  -> CÂU LỆNH IF RA ĐỜI VÀ CÁC BIẾN THỂ, IF, IF/ELSE, IF/ELSE/IF..., SWITCH-CASE,?
							NESTED

  if (điều gì đúng, mệnh đề so sánh mà đúng)
  {
	thì làm những gì ở đây
	những lệnh sẽ làm khi điều gì ở trên mà đúng 
  }

  if (điều gì đúng, mệnh đề so sánh mà đúng)
	thì chỉ làm 1 việc, ko nhiều hơn 1 việc, ko cần cặp ngoặc nhọn.

  TUYỆT ĐỐI CẤM: if (...); là toang mẹ nó lệnh if, biến thành câu cụt, CPU chạy sai
  Vd: okie
	if (trời mưa, đúng là trời mưa, trời == mưa)
		thì đem đồ trên sân thượng vào nhà;

  Vd: okie
	if (trời mưa, đúng là trời mưa, trời == mưa)
	{
		thì đem đồ trên sân thượng vào nhà;
	}

  Vd: okie - nếu ép làm nhiều việc thì BẮT BUỘC CÓ {...}
				gom các lệnh thực thi dưới 1 tình huống nào đó

	if (trời mưa, đúng là trời mưa, trời == mưa)
	{
		thì đem đồ trên sân thượng vào nhà;
		thì kéo giếng trời/thông gió kẻo mưa tạt;
		thì kéo giàn che lan đột biến kẻo hư hết bông;
		thì đóng các cửa sổ kẻo mưa tạt;
	}

* KHI CODE CÓ QUÁ NHIỀU IF ELSE LỒNG NHAU (NESTED) DO TRỤC SỐ MÌNH XÉT NHIỀU ĐOẠN, KHOẢNG
............ A B C D E ... X Y Z ......  a b c d ...

- TA LẬP TỨC SUY NGHĨ NGAY ĐẾN CÁCH VIẾT ĐƠN GIẢN HƠN - DÙNG SWITCH - CASE,
  THAY CHO CÁC IF LỒNG NHAU NHIỀU CẤP, NHIỀU IF NGANG NGANG NHAU.

biến có value nào đó
biến = value;
if (biến so sánh...)	      if (biến so sánh...)	     switch (biến)
   thì làm gì 			   thì làm gì		     {
if (biến so sánh...)	      else if (biến so sánh...)	        case value-1:
   thì làm gì 			   thì làm gì			    thì làm gì
if (biến so sánh...)	      else if (biến so sánh...)		    break; 
   thì làm gì 			   thì làm gì			case value-2:
			      ...				    thì làm gì
								    break;
							        case value...:
								    thì làm gì
							 	    break;
								default: 
								//còn lại của world
								//else sau khi loại
								//trừ tất cả ở trên
								    thì làm gì
							      }

-> CPU có thể lag xíu	      CPU loại trừ...

- LƯU Ý KHI XÀI SWITCH: 
SWITCH (BIẾN) THÌ BIẾN BẮT BUỘC PHẢI LÀ CÁC KIỂU DỮ LIỆU RỜI RẠC!!!
rời rạc, giá trị nào gọn gàng giá trị đó
1, 2, 3, 4, -5, -10, a, b $

ko rời rạc
1,1....
3,1415....
10/3 = 3,33333333...
giữa 3 và 4 có bao nhiêu con số

-> Túm lại switch(biến bắt buộc phải là kiểu int, char, KO DÙNG BIẾN THỰC)

-----------------------------------------------------------------------------------
 2. THẾ GIỚI CÁC LỆNH LẶP - ÉP CPU VÒNG VÒNG, XÀ QUẦN, LOOP

* 2 LOẠI HÌNH THỨC LẶP KHÁC NHAU
 - LẶP VÀ BIẾT TRƯỚC SỐ LẦN LẶP.
   Vd: + Soát vé của sân Mĩ Đình: 6000 vé phải được kiểm tra, mời khán giả vào!!!
       + Thủ tục vào phòng thi, giám thị lặp lại việc: kiểm tra thông tin thí sinh.
       + Nhập từ bàn phím 50 con số nguyên -> scanf() 50 lần.

 - LẶP CHƯA BIẾT TRƯỚC SỐ LẦN LẶP
   Vd: + Mày cứ làm đi, đến khi tao bảo dừng thì dừng!!!
       + Đi đường, cứ kéo tay ga, miết, hoài, mãi, khi nào gặp ngã 3, có gương cầu,
	 thì dừng lại.
       + Nhìn 1 dấu hiệu xảy ra và mình sẽ dừng!!!
       + Nhập từ bàn phím một số lượng số nguyên, khi nào nhấn số 0 thì dừng!!!

* CÁC LỆNH LẶP: 
- FOR
- DO-WHILE		dịch chung 3 từ này là LẶP LẠI 1 LỆNH/NHÓM LỆNH NÀO ĐÓ
- WHILE
TƯƠNG ĐƯƠNG NHAU, ÉP CPU VÒNG VÒNG 1 SỐ LẦN, HOẶC VÔ TẬN.

* VÒNG LẶP FOR - BẠN MUỐN CPU LẶP BAO NHIÊU LẦN, CHỈ CHO NÓ...

CHƠI VỚI FOR CẦN CÓ 1 BIẾN ĐỂ ĐẾM SỐ LẦN CẦN LẶP
			
			      nếu còn đúng, thì tiếp tục
for (trạng thái bước vào lặp; trạng thái dừng lặp; bước nhảy/biến đếm số lần lặp)
{
	các lệnh cần lặp here!!!
}

//nếu chỉ lặp 1 lệnh, 1 lệnh được lặp nhiều lần, ko cần {...}

for (biến chặn đầu; kiểm tra chặn đuôi; bước nhảy)
{
	những lệnh cần lặp lại nằm trong đây
}

for(biến chặn đầu; kiểm tra chặn đuôi; bước nhảy)
	1 lệnh cần lặp lại nằm trong đây, ko cần cặp ngoặc nhọn

for(biến chặn đầu; kiểm tra chặn đuôi; bước nhảy);  //TOANG CON MẸ NÓ RỒI
						    //CÂU CỤT NHƯ KIỂU IF, SAI!!!
{
	những lệnh cần lặp lại nằm trong đây
}

FOR - VÒNG LẶP NÓI CHUNG CÓ LOẠT DẠNG BÀI TẬP LIÊN QUAN ĐẾN DÃY SỐ
- Tính n! = 1.2.3.4.5...n
- Tính tổng 1 + 2 + 3 + 4 + ... + n
- Nhập 1 dãy số 1 10 1000 -5 100 201 300...
	- đếm xem đã nhập bao nhiêu số?
	- đếm xem đã nhập bao nhiêu chẵn, lẻ, chia hết 10
	- hỏi xem đã có nhập mấy số 5
	- tổng của đám số chẵn
	- tổng của đám chia hết cho 3
	- có số 10 xuất hiện trong đám đã nhập hay ko???
	-...

* VÒNG LẶP DO - WHILE
						
do					
{					
	còn đúng thì còn lặp lại		
	các lệnh trong đây;			
} while (điều gì mà còn đúng);				
	 mệnh đề so sánh

- CÒN ĐÚNG THÌ CÒN LẶP LẠI!!!
- CỨ LÀM TRƯỚC 1 CÁI ĐI ĐÃ - DO	
- LÀM XONG, HỎI CÓ NÊN LÀM TIẾP KO
- Ko chặn từ sớm, ko soát vé từ sớm, kiểm tra/soát vé sau.
- Vd: thi học kì
  -> Giám thị: các em vào phòng đi, lát kiểm tra giấy tờ sau.

* VÒNG LẶP WHILE
	
	mệnh đề so sánh
while (điều gì mà đúng/còn đúng)
{
	còn đúng thì còn lặp lại		
	các lệnh trong đây;
}

- CÒN ĐÚNG THÌ CÒN LẶP LẠI!!!
- RỤT RÈ HƠN; THẤY ĐÚNG TỪ ĐẦU THÌ LÀM
- LÀM XONG, HỎI CÓ NÊN LÀM TIẾP KO
- Bảo vệ gác ngay từ đầu, hỏi/soát từ lúc đầu tiên, ổn cho vào, ko ổn ko cho vào, có thể ngay từ lần đầu tiên soát vé sớm.
- Vd: thi học kì
  -> Giám thị: đứng chặn cửa gọi tên!!! kiểm tra giấy tờ!!!

* LÀM SAO THOÁT VÒNG LẶP KHI LỠ VÀO

- Điều kiện (còn đúng thì còn lặp) phải có lúc nào đó được sai. 
  Vd: ++ để cho () sai

- Chơi kiểu vô tận () phải có break lúc nào đó bên trong.

* SỰ KHÁC BIỆT CHÍNH YẾU CỦA DO-WHILE vs. WHILE LÀ GÌ?
- DO-WHILE luôn chạy được ít nhất 1 nhát bên trong, chữ DO cứ làm xét sau.
- WHILE tệ nhất ko làm được nhát nào bên trong.
- DO-WHILE can run the inside statement at least once ~~ the statements are executed at least once!!!

* HIỆU ỨNG LỀ - TRÁI TIM BÊN LỀ - SIDE EFFECT
- Ta bị mất kiểm soát, vô tình quên giá trị đang có của biến count nào đó, mà đem đi dùng tiếp.
- CẦN LƯU Ý RESET BIẾN COUNT NÀY VỀ ĐÚNG GIÁ TRỊ MONG MUỐN KHI VÀO VÒNG LẶP MỚI.		

===================================================================================
VII. THƯ VIỆN/LIBRARY

Vd: #include <stdio.h>
    #include <stdlib.h>
    #include <ctype.h>

- Mở cốp xe Innova, lấy côn nhị khúc ra chơi. Cái hòm chứa đồ chơi dùng nhiều lần.
- Đây là tập tin trên HDD/SSD chứa các hàm, các xử lí có sẵn mà ta lôi ra xài.
- Ta cần biết hòm nào chứa đồ gì -> tên hòm.h ~~~ các cốp xe chứa đồ chơi.
- Tên món đồ chơi là các hàm nằm trong cốp xe ctype.h, string.h, math.h,...
- Các hòm.h phân loại các đồ chơi/các hàm tương ứng ~~~ các cốp xe chứa các loại hàng khác nhau.
- include <> mở cốp xe tương ứng -> đã mở thì lấy hàng/hàm ra mà xài!!!
- .h được gọi là LIBRARY - THƯ VIỆN/NƠI CHỨA NHIỀU ĐỒ CHƠI DÙNG CHUNG, XÀI LẠI NHIỀU LẦN.

===================================================================================
VIII. HÀM LÀ GÌ?

* Hàm là gì?
file:///D:/SoftwareEngineer/C/c-craftsman-main/atlas/[giao.lang]%20C%20Atlas-22.0111.pdf

* Các loại hàm cơ bản
file:///D:/SoftwareEngineer/C/c-craftsman-main/atlas/[giao.lang]%20C%20Atlas-22.0111.pdf

* Lợi ích
- Re-use: tái sử dụng, gọi lại, dùng lại đoạn lệnh này chỉ qua tên gọi.
- Easy to maintain: dễ bảo trì/sửa code.

* GHI CHÚ QUAN TRỌNG VỀ LỆNH RETURN:
- Nếu CPU chạm được lệnh return, thì: NÓ SẼ KẾT THÚC HÀM NGAY VÀ LUÔN, KO CARE CÁC LỆNH SAU NÓ...
- Một hàm được quyền có bao nhiêu lệnh return??? Có 2 style thiết kế hàm có trả về giá trị:
  + Hàm chỉ có duy nhất 1 lệnh return đặt ở cuối hàm. Để kiểm soát value đầu ra cho
    nhất quán - NHÀ 1 CỬA EXIT (chuẩn mực).
  + Hàm có NHIỀU LỆNH RETURN, NHIỀU CỬA THOÁT!!! chỗ nào đã xác định được value của
    hàm, thì dừng luôn, ko cần chờ đến cuối mới RETURN. CÓ ĐƯỢC VALUE TRONG BẤT KÌ
    TÌNH HUỐNG NÀO, THÌ DỪNG!!!, VÌ HÀM CẦN VALUE, CÓ THÌ DỪNG.
- RETURN MẠNH HƠN BREAK, BREAK CHỈ THOÁT LẶP, CÒN RETURN THOÁT HÀM, DÙ CPU ĐANG Ở TRONG LẶP.
- Nếu code có if else và trong if else đều có return
  if()							if()
  {							{
	...;							...;
	return;							return;
  }							}
  			viết tương đương và gọn hơn 
				bỏ else
else							...; //lệnh của else here
  {							return;
	...;
	return;
  }

  nếu ko có return sớm, COI CHỪNG NGUY HIỂM

  if()
  {
	...;	//ko return sớm
  }
  ...;		//lệnh này lúc nào cũng được chạy!!!, nó ko phải là ELSE.
  return;	

* Có 2 loại hàm nâng cao:
  - Hàm có sẵn mà thiên hạ viết sẵn rồi, cho mình xài. Tìm đem về xài. Tương tự như
    mua máy xay sinh tố có sẵn, đem dùng thôi, mua trái cây nhét vào, nhận sinh
    tố trả về.
  -> PRE-DEFINED FUNCTION
  Vd: tolower(kí tự) -> chữ thường
      pow(5, 2) -> trả về 5^2
      ...
      Đặt hàm này vào những ngăn tủ, cốp xe để phân loại. 
      Ngăn tủ ở trong C chứa những hàm được phân loại rồi thì gọi là thư viện
      .h
      #include <math.h> ta sẽ mở ngăn math, 1 đống hàm toán học cho mình dùng.
      #include <ctype.h> mở ngăn toàn hàm xử lí ASCII
      #include <string.h> mở ngăn toàn là hàm xử lí câu văn/string/chuỗi.
      HẦU HẾT HÀM LOẠI 4, RE-USE

  - Hàm tự làm, nhận vào và trả về, giống hàm nhà người ta.
    -> USER-DEFINED FUNCTION
    Vd: getFactorial()

===================================================================================
IX. CẤU TRÚC/TỔ CHỨC CODE CỦA APP

#include <stdio.h>			//Khai báo muốn xài đồ chơi,
#include <stdlib.h>			//xài hàm viết sẵn của ai đó.
#include <thư viện nào đó . h> 

#define...				//Định nghĩa một lable - nhãn.

const double VAT = 0.1;			//Định nghĩa, khai báo có hằng số,
const float PI = 3.14;			//biến read only, ko cho đổi value.
const int ...				

int currentYear = 2024;			//Khai báo biến toàn cục - GLOBAL VARIABLE,
char letter = '$';			//biến nằm ngoài, ko thuộc hàm nào cả.
					//Cẩn thận side-effect do hàm nào cũng có
					//quyền đổi value của nó.

int getFactorial(int x);		//Prototype - nguyên mẫu hàm
void printMenu();			//Khai báo rằng tao sẽ chế ra các hàm của 
					//riêng tao.
					//Signature of a function - TÊN HÀM!

int main(.....) {			//Nơi cuộc chơi bắt đầu. 
	các hàm của ta();		//CPU tìm hàm này chạy trước.
	các hàm của người ta();
	được gọi CALL, INVOKE ở đây;
	return 0; //coi như hàm chạy thành công
}

int getFactorial(int x) {		//code của các hàm của ta ở đây
	code tính n! ở đây;		//IMPLEMENTATION OF A FUNCTION
	return ?			//BODY OF FUNCTION 
}					//code của hàm - thân hàm
void printMenu() {
	KHAI BÁO BIẾN;			//LOCAL VARIABLE - BIẾN CỤC BỘ
					//HÀM NÀY KO THẤY BIẾN CỦA HÀM KHÁC.
					//SCOPE OF VARIABLE - ta có thể truy xuất
					//được biến hay ko.
	code của hàm;
}

* GHI CHÚ CỰC KÌ QUAN TRỌNG:
- CÁC CÂU LỆNH TÍNH TOÁN, IF-DO-WHILE-FOR BẮT BUỘC PHẢI NẰM TRONG HÀM NÀO ĐÓ, KO ĐỨNG LƠ LỬNG NGOÀI HÀM, CPU BỐI RỐI KO BIẾT CHẠY KHI NÀO, VÌ NÓ CHỈ CHẠY HÀM ĐƯỢC GỌI TRONG MAIN().
- HÀM CHỨA LỆNH!!! SAU ĐÓ HÀM LẠI BIẾN THÀNH LỆNH ĐỂ GỌI DÙNG!!!

===================================================================================
X. TRUYỀN THÁI Y - KĨ THUẬT ĐƯA ĐẦU VÀO CHO HÀM

1. TRUYỀN THAM TRỊ - PASS BY VALUES - HÀM CHƠI VỚI VALUE THUẦN
- Tao chỉ cần value của mày, ko quan tâm tên mày.

2. TRUYỀN THAM CHIẾU - PASS BY REFERENCE - HÀM CHƠI VỚI POINTER
- Muốn thay đổi giá trị ở nơi gọi hàm, thì cần đưa địa chỉ cho hàm, hàm sẽ thay đổi nơi gốc gọi hàm.
Vd: void swap(int* a, int* b);

===================================================================================
XI. MẢNG - ARRAY

1. Mảng là gì?

* MẢNG LÀ KĨ THUẬT KHAI BÁO NHIỀU BIẾN CÙNG KIỂU, CÙNG LÚC, CÙNG TÊN, Ở SÁT NHAU TRONG RAM.

Vd: float col[10]; //xong, có 10 biến cùng tên là col rồi.
    col[0] là biến đầu tiên, 4 byte đầu tiên được đặt tên là [0].
    col[1] là 4 byte kế, biến kế tiếp.
    col[2] chỉ là 1 biến float thoi mà, vấn đề là tên đi kèm [?]
    //mày là biến thứ mấy
    ...
    col[9] là đứa cuối cùng!!!
    //tên biến phức tạp hơn, [biến thứ mấy tính từ 0]
    //mọi quyền lợi của biến xài như biến LẺ, chỉ là có tên đặc biệt.

* MẢNG: KHAI BÁO NHIỀU BIẾN, GIÁ PHẢI TRẢ LÀ TÊN BIẾN PHỨC TẠP HƠN. 
	LỢI THẾ: KHAI BÁO NHANH GỌN.
		 VÒNG LẶP!!! VÌ NGOẶC VUÔNG [ĐƯỢC QUYỀN THAY ĐỔI ỨNG VỚI BIẾN THỨ MẤY] ~~ [i TĂNG TỪ 0 ... CUỐI MẢNG]

* Mỗi biến trong mảng, tính từ 0, được gọi là 1 phần tử mảng, ELEMENT.

* [i] i chạy từ 0..cuối mảng.
  [index chỉ số phần tử/thứ tự/biến thứ mấy!!!]

* GHI CHÚ ĐẶC BIỆT VỀ TÊN MẢNG
- TÊN MẢNG, LÀ TÊN CHUNG CHO CẢ ĐÁM BIẾN, FLOAT C[10];
				TA CÓ 10 BIẾN C[0] C[1] C[2]...
  NGOÀI RA C NGẦM ĐỊNH CÒN 1 BIẾN "ẨN" TÊN LÀ C

  TÊN MẢNG ĐƯỢC XEM LÀ 1 BIẾN RẤT ĐẶC BIỆT!!! RẤT ĐẶC BIỆT
  NÓ KO THÈM LƯU VALUE BÌNH THƯỜNG (5 10 15 20 ...)

  NÓ LẠI ĐI LƯU VALUE LÀ ĐỊA CHỈ CỦA 1 BIẾN KHÁC!!!
  TÊN MẢNG LÀ 1 BIẾN, LƯU ĐỊA CHỈ/SỐ NHÀ CỦA ELEMENT ĐẦU DÃY MÀ NÓ QUẢN LÍ.
  TÊN MẢNG LÀ BIẾN MÁ MÌ, TÚ ÔNG TÚ BÀ, QUẢN LÍ NHIỀU HOTBOY, HOTGIRL/TỨC LÀ ELEMENT.
  TÊN MẢNG CHỈ NẮM ĐẦU CHÀNG/NÀNG ĐẦU DÃY
			LƯU SỐ PHONE/SỐ NHÀ THẰNG ĐẦU DÃY, BIẾN [0]

2. Cách khai báo mảng

* float c[10];

* float c[10] = {1, 1, 2, 3, 5, 8}
		  //Cho 6 điểm hoy, mà lại có 10 biến
		  //Gán value ngay cho 6 phần tử đầu của mảng
		  //[0] = 1; [5] = 8
		  //Biến còn lại value DEFAULT = 0; KO RÁC LUNG TUNG.

* float c[] = {2, 4, 6, 8, 10};
- Câu lệnh này ko nói rõ có bao nhiêu biến được cấp. Nhưng lại gán sẵn value cho 1 số biến. Mảng sẽ tự động được cấp số biến tùy theo số lượng value được gán.
- Bài này là 5 biến - chính là mảng [5]

* float c[];
- Bị chửi vì ko nói rõ bao nhiêu biến

* Phải nói rõ số biến cần xin, gán value sau cũng được. 
  - Vừa xin bao nhiêu, vừa gán.
  - Vừa gán, mà ko thèm nói xin, thì sẽ cấp theo số gán.

3. KĨ THUẬT PHẤT CỜ

- Kĩ thuật phất cờ chơi với nhiều dữ liệu, ta giả định 1 điều gì đó từ ban đầu, sẽ phất khi data có điều gì đặc biệt xảy ra!!!

4. THUẬT TOÁN SẮP XẾP MẢNG - NƯỚC LÊN THUYỀN LÊN - INTERCHANGE SORT

int a[] = {5, -10, 15, -20, 25};

[0] -> so sánh từ [1] đến cuối -> for (i = 1 -> cuối)
				     if [0] > [i] -> swap

[1] -> so sánh từ [2] đến cuối -> for (i = 2 -> cuối)
				     if [1] > [i] -> swap

[2] -> so sánh từ [3] đến cuối -> for (i = 3 -> cuối)
				     if [2] > [i] -> swap

[3] -> so sánh từ [4] đến cuối -> for (i = 4 -> cuối)
				     if [3] > [i] -> swap
		dừng được rồi

int t; //t, tmp, temporary

for (int i = 0; i < length - 1; i++)

    for (int j = i + 1; j < length; j++)	//i = 0, for trong đi từ 1

	if (a[i] > a[j])	//ASCENDING
		t = a[i];
		a[i] = a[j];
		a[j] = t;

//	if (a[i] < a[j])	//DESCENDING
//		t = a[i];
//		a[i] = a[j];
//		a[j] = t;

===================================================================================
XII. POINTER - CON TRỎ - BIẾN DANH BẠ - ĐỊA CHỈ

1. CÁCH KHAI BÁO BIẾN POINTER

     char*, int*, long*, float*, double* ...

	int* hari = &yob;

 1. int*  : 8 byte (nếu win 64-bit) chứa value KHÁC THƯỜNG, chứa địa chỉ, tọa độ của biến int thường khác.   
 2. hari  : tên biến, đại diện cho value KHÁC THƯỜNG %u
 3. hari  : Mày có gì? Em có value KHÁC THƯỜNG, ĐỊA CHỈ 6M.
 4. *hari : ĐẾN nhà kia đi mày. GHÉ nhà có địa chi 6M đi mày.
 5. &hari : Nhà mày ở đâu? Nhà em ở địa chỉ KHÁC, anh quan tâm làm chi? 

2. POINTER LÀ GÌ

* Con trỏ - mày là 1 biến/1 hộp, value on-off của mày hơi đặc biệt, thay vì value thường (5 10 15 20) xài luôn, thì value của mày lại là tọa độ của biến thường khác/địa chỉ biến thường khác.

* Lấy được value của biến thường (int yob) xài luôn.
  Lấy được value của biến con trỏ, ko xài ngay, vì nó là tọa độ, vì nó trỏ, phải lóc cóc chạy đến tọa độ kia thì mới có value thường.
	
	BIẾN-CON-TRỎ CHẠY ĐẾN CHỖ XA ~~~ BỐC MÁY GỌI THẰNG BẠN QUA SỐ DI ĐỘNG

	int A = 2002; -> THƯỜNG

	int* P = &A;  -> P CÓ ĐỊA CHỈ %u
			 *P ĐẾN NHÀ A, NGỒI NHÀ A RỒI, BỐC MÁY GỌI A RỒI
			 *P CHÍNH LÀ A, THÌ THOẢI MÁI SỬA QUA *P - NGƯỜI ĐẠI DIỆN
		
			 *P = 5 ~~~ A = 5

	int* P LÀ ĐỂ NÓI RẰNG P SẼ MÓC VÀO VÙNG BIẾN A/TRỎ VÙNG A, GẮN KẾT A, LƯU 
	SỐ ĐIỆN THOẠI CỦA BẠN THÌ GẮN KẾT NÓ.

	DANHBA* P = SỐ THẰNG BẠN
		*P DÙNG SỐ THẰNG BẠN ĐỂ CONTACT

* Con trỏ là một hình thức sờ vào biến khác. Biến khác có thêm 1 tên mới (*hari, tt).

3. TÍNH TOÁN VỚI POINTER

* VÌ CON TRỎ CŨNG LÀ 1 BIẾN, KO AI CẤM NÓ ++ -- CỘNG VỚI 1 CON SỐ NÀO ĐÓ!!!

int tt = 5000;
tt -= 1000; //tt còn 4000

int* hari = &tt; //hari gắn với ví ở mông tt
		 //hari đã gắn với tọa độ ví

*hari -> mở cái ví ~~~ biến tt
*hari = *hari - 3000;   ~~~ tt = tt - 3000;
*hari ~~ tt còn lại 1000
biến tt có 2 tên gọi: tt, *hari

* TUY NHIÊN: tt++ biết rồi

	     (*hari)++

	     hari++ ???

	     *(hari++)

  hari++			SẼ KHÁC 	*hari++

Biến con trỏ				
Tao đang lưu tọa độ
Bắt tao thay đổi tọa độ à!!!

++ TĂNG TỌA ĐỘ LÊN
-- GIẢM TỌA ĐỘ XUỐNG

++ biến con trỏ là nhảy 1 căn nhà
căn nhà bao nhiêu byte thì nhảy bấy nhiêu byte
++ tăng 1. 1 CĂN, KO PHẢI 1 BYTE

Vd: Nhà tao nhà số 2
    Nhà mày kế nhà tao, số 4
    Sang nhà tao 1 căn, về số, thì là số 4

CON TRỎ ++ -- NGHĨA LÀ NHẢY VÈO MẤY BYTE, VÌ NÓ PHẢI SANG NHÀ KẾ, 1 NHÀ CHIẾM NHIỀU BYTE, ĐI 1 NHÀ, ĐI 1 BIẾN, LÀ ĐI NHIỀU BYTE.

4. HACK RAM QUA CON TRỎ

63 ? -> 0011 1111

36 $ -> 0010 0100

	0000 0000
	0000 0000
63 ? -> 0011 1111
36 $ -> 0010 0100

0000 0000  0000 0000  0011 1111  0010 0100
---------  ---------  ---------  ---------
  0		0 	63	    36		Decimal -> 16.164

IP, 32 BIT, MÃ SỐ MÁY TÍNH ~~~ MÃ SỐ SV

0000 0000   0000 0000   0000 0000   0000 0000
0000 0001   0000 0001   0000 0001   0000 0001 
    1           1           1           1

IP:	  1.1.1.1
     Decimal -> 16.843.009

IP máy mình: 10.88.52.96

    10		   88	           52		 96
 0000 1010	0101 1000	0011 0100     0110 0000

int gift = 16164;
char* hack = &gift;
printf("%c", *hack); //nó chỉ quét qua 1 byte vì khi khai báo biến con trỏ là char*
		     //do đó nó in ra kí tự $

* TRONG TRƯỜNG HỢP TA CÓ MỘT DÃY SỐ, LÀM THẾ NÀO ĐỂ MÁY TÍNH HIỂU RẰNG ĐÓ LÀ ĐỊA CHỈ CHỨ KHÔNG PHẢI LÀ MỘT VALUE THƯỜNG?
int* hari;
hari = (int*)6487572; //cast/casting/ép kiểu/ép chó thành mèo
		      //đưa bột vào khuôn ra bánh
		      //đưa địa chỉ/con số qua (int*)
		      //tức là địa chỉ

5. HÔN NHÂN GIỮA MẢNG VÀ CON TRỎ!!!

* TÊN MẢNG CŨNG LÀ 1 BIẾN, BIẾN MÁ MÌ, LƯU SỐ NHÀ CỦA BIẾN ĐẦU TIÊN, VALUE CỦA BIẾN TÊN MẢNG LÀ SỐ NHÀ. TÊN MẢNG LƯU SỐ NHÀ THẰNG A[0] ĐẦU DÃY. TÊN MẢNG LÀ CON TRỎ RỒI, HỎI NÓ CÓ GÌ, EM CÓ ĐỊA CHỈ!!!

* In mảng bằng tên mảng
printf("The array has values (using pointer): \n");
for (int i = 0; i < 5; i++)
	printf("a[%d] = %d\n", i, *(a + i));

//Vẫn giữ chốt a trỏ đầu dãy, + i để dời nhà, lấy địa chỉ mới
//*(a + i) để lấy value vùng trỏ, mà ko mất chốt!!!

* TUY NHIÊN:
- int* hari là con trỏ tường minh, tức là nó thoải mái ++ --, trỏ thoải mái luôn

- a tên mảng được gọi là con trỏ ngầm/ko tường minh/con trỏ hằng.
  Là con trỏ, nhưng cấm đi lung tung, việc nó là phải chốt đầu mảng, ko cho ++ --
  nhưng được quyền dùng nó + và - để tăng tọa độ!!!
  Ko được rời vị trí, CHỈ VÀ LUÔN PHẢI TRỎ VÀO THẰNG A[0] VÌ BIẾN CON TRỎ LÀ MÁ MÌ,
  PHẢI QUẢN LÍ ĐÁM CHÂN DÀI A[I]

- Tên mảng đứng 1 mình là tương đương int* hari
  Tại sao tên mảng, người ta kí hiệu luôn là con trỏ 
  Vd: int f(int a[])  ~~~ int f(int* a)

===================================================================================
XIII. MẢNG ĐỘNG - DYNAMIC ARRAY	

1. CÁC VÙNG RAM CỦA 1 APP

* DATA SEGMENT: CHỨA BIẾN TOÀN CỤC.

* CODE SEGMENT: CHỨA TOÀN BỘ LỆNH/CODE CỦA APP.

* HEAP SEGMENT: DYNAMIC ZONE: MALLOC(), CALLOC(). CẤP PHÁT ĐỘNG DYNAMIC ALLOCATION. 

* STACK SEGMENT: TOÀN BỘ LOCAL VARIABLE VÀ CÁC LỆNH GỌI HÀM.	

2. CÁCH CHƠI VỚI MẢNG ĐỘNG

int a[] = {5, 10, 15, 20, 25, 30};  
int* p = (int*)malloc(24); 

//em xin Windows 24 byte, chia hết cho 4
//Con trỏ int mai mốt sẽ nhảy 4 ++ --
//Hàm malloc() xin 24 byte ở HEAP, cắm cọc, giăng dây 24 byte
//Chốt tọa độ đầu, byte đầu, đưa địa chỉ đó cho p
//p lưu tọa độ đầu tiên của 24 byte
//p có mùi giống tên mảng, biến má mì, cai quản 24/4 = 6 cụm 4 - 6 biến int
//p giống tên mảng, vì lưu tọa độ cụm 4 đầu dãy, lưu đầu dãy
//p được quyền dùng như mảng, tức là p[0] 4 byte đầu
				     p[1] tên 4 byte kế
//Khai báo con trỏ, xài như mảng.

//Đã xin thì nên trả lại
free(p); 
//trả lại vùng RAM p đang trỏ cho Windows sau khi chạy xong.
//HEAP trả lại cho Windows
//p nằm trong Stack, Windows chủ động thu lại vùng RAM này.
//NẾU KO FREE VÙNG MALLOC(), MÀ CỨ CHẠY APP CHẠY HÀM NHIỀU LẦN, VÙNG HEAP CỨ TĂNG DẦN. WINDOWS KO LẤY LẠI ĐƯỢC, RAM GIẢM DẦN DUNG LƯỢNG.
//LIÊN QUAN ĐẾN HIỆN TƯỢNG RÒ RỈ MEMORY, LEAK MEMORY.

===================================================================================
XIV. CHUỖI TRONG LẬP TRÌNH C

1. CHUỖI LÀ GÌ?

* CHUỖI CHẲNG QUA LÀ 1 ĐÁM KÍ TỰ ĐỨNG SÁT NHAU - THÀNH 1 CÂU VĂN - STRING - CHUỖI KÍ TỰ. 1 ĐÁM KÍ TỰ Ở SÁT NHAU - SÁT NHAU CHỈ CÓ THỂ LÀ MẢNG - CHUỖI LÀ 1 MẢNG KÍ TỰ.

* MUỐN LƯU 1 ĐÁM KÍ TỰ LIỀN NHAU, LÁT HỒI IN RA LIỀN NHAU -> CẦN 1 MẢNG KÍ TỰ.

* CHUỖI LÀ 1 MẢNG KÍ TỰ VÀ KẾT THÚC BỞI KÍ TỰ NULL, KO CẢN TẦM NHÌN, NHƯNG MẢNG KÍ TỰ KO CÓ NGHĨA LÀ CHUỖI.

* TẠI SAO CHUỖI LẠI CẦN KẾT THÚC?
-> Name/tên của bạn dài ngắn khác nhau, ko cố định. Khi ta khai báo lưu tên người, ta cần mảng char.
-> char name[50] trong ram có 50 byte liên tiếp nhau!!! để lưu được 50 kí tự.
-> Nhưng tên mỗi người có thể ko xài hết 50 kí tự, vậy thì xài đến đâu thì in đến đó, ko xài hết 50, phí sức.

* ĐƯA MẢNG CHO HÀM CHÍNH LÀ ĐƯA CON TRỎ.

2. CÁCH KHAI BÁO CHUỖI, GÁN GIÁ TRỊ CHO CHUỖI, VÀ NHẬP CHUỖI TỪ BÀN PHÍM

* Khai báo chuỗi và gán giá trị cho chuỗi: 

- Gán lúc khai báo: 

char n1[50] = "Ahihi"; //C tự điền NULL vào cuối chuỗi.

char n2[50] = {'A', 'h', 'i', 'h', 'i', 0};

char n2[50] = {'A', 'h', 'i', 'h', 'i', '\0'};

- scanf();

- strcpy(name, n1); 
//n1 đổ vào name.
//Vào mảng n1 copy từng kí tự n1 đổ sang tương ứng name, copy luôn cả null cuối chuỗi.

- Cấm ko được gán ch;uỗi/mảng dùng dấu =; dấu = chỉ dùng lúc khai báo hoặc gán 1 biến đơn. Cấm tuyệt đối gán 2 mảng dùng dấu =.
Vd: char name[50]
    name = "Ahihi"; //sai

* Lưu ý khi nhập chuỗi từ bàn phím và in chuỗi ra màn hình
- %s: chơi với null để kết thúc.
- %c: for [i].
- Dấu cách dùng để phân biệt các giá trị gõ vào.
- Dấu enter dùng để kết thúc nhập.

* Nhập chuỗi từ bàn phím:
- Cách 1:
scanf("%s", name); 
//Ko lấy chuỗi sau dấu cách đầu tiên.

- Cách 2:
scanf("%[^\n]", name);

- Cách 3: Cặp lệnh mới
gets(name); //nhập vào ~~~ scanf()
	    //ko chặn độ dài nhập -> khá nguy hiểm.

puts(name); //in ra    ~~~ printf() + '\n'

- Khi nhập chuỗi quá độ dài khai báo, thì các biến đằng sau bị đè dữ liệu lên, từ đó app bị chết.

char name[10];
scanf("%9[^\n]", name); 
//nhận tối đa 9 kí tự, chấp mày gõ dài.
//phải chừa lại 1 byte để dành chỗ cho kí tự NULL để kết thúc chuỗi.  

3. XÓA 1 KÍ TỰ TRONG CHUỖI

char s[50] = "123456789"; //50 byte trong RAM

tui muốn xóa '5'

char s[50] = "12346789"; //vẫn 50 byte trong RAM
			 //nhưng length - 1, vẫn sát nhau
			 //DỒN VALUE nhưng số byte trong RAM vẫn 50.
-> HIỆU ỨNG ĐỔ DOMINO ĐỔ DỒN VỀ TRƯỚC

int pos = ?; //Muốn xóa kí tự bao nhiêu tính từ 0, còn nếu tính ngoài đời thì - 1.
for (int i = pos; i < strlen(s); i++)
		s[i] = s[i + 1]; 

4. XÓA TẤT CẢ CÁC KÍ TỰ LẠ NÀO ĐÓ

char s[50] = "A%^&^%$$$%%B2*-/-/C3*-/-D4/-**/";

for (int i = 0; i < strlen(s); i++)
	if (!(tolower(s[i]) >= 'a' && tolower(s[i]) <= 'z')) {
		for (int j = i; j < strlen(s); j++)
			s[j] = s[j + 1];
		i--; 
	}

5. THUẬT TOÁN SO SÁNH 2 CHUỖI
-> So sánh từ trái sang phải của 2 chuỗi ở cùng vị trí [i].
-> Nếu thấy khác biệt thì dừng ngay để kết luận.
-> So sánh theo mã ASCII.
-> Chuỗi dài hơn chưa chắc lớn hơn. Quan trọng là mã ASCII và sự khác biệt.
-> Các hàm so sánh 2 chuỗi:
* strcmp(s1, s2);

//trả về 3 giá trị:

-1: thua

0 : huề

+1: thắng

* stricmp(s1, s2); //ignore.
		   //so sánh ko quan tâm hoa thường, 

===================================================================================
XV. TẬP TIN - FILE

1. FILE LÀ GÌ
- FILE đóng 2 vai trò: vừa là input - bàn phím - để đưa data vào RAM, vừa là output - màn hình - in data vào HDD/SSD -> I/O.
- Nhiều byte trên HDD/SSD chứa ON-OFF, chứa info. Nắm đầu thằng đầu dãy byte -> Pointer -> FILE* f -> trỏ đầu dãy byte lưu để data.
- Tên: FILENAME.
- PATH: mày nằm ở đâu, ngăn nào - dir(directory)/folder.
	\ - windows
	/ - Linux, MacOS
- Tập tin kết thúc bằng byte EOF - End of file - value trong RAM: 1111 1111 (hệ 2) 
								  -1	    (hệ 10)
  -> Đọc tập tin vào RAM -> Dùng do - while đến khi nào chạm được EOF.

2. CHƠI VỚI FILE

* HDD/SSD do OS quản lý, phải xin phép OS khi chơi với file.
- Đụng tập tin để làm gì?
  -> OPEN -> fopen(f, mode) 
	  -> mode gồm: r - read: đọc.
		       w - write: tạo mới, xóa cũ.
		       a - append: chưa có thì tạo mới, có rồi thì nối vào tiếp.

- Thao tác trên tập tin: lấy RAM làm trung tâm
  + Ghi data ra đĩa.  -> Ctrl-Save/Write/Ouput.
  + Đọc data vào RAM. <- Ctrl-Open/Read/Input.
  -> LOOP to EOF 
  -> 1 loạt các hàm f(f...);		

- Khi xài xong, trả lại cho OS
  -> CLOSE -> fclose(f);	

3. 2 LOẠI TẬP TIN

* Tập tin văn bản - .txt
- Mỗi byte trên HDD/SSD là 1 kí tự/là mã ASCII của 1 kí tự.
- Open tập tin - read - đưa vào RAM để xem -> thấy ngay kí tự. Xem = Notepad,...
- 
+ READ:  fgetc(f) -> Kí tự được đưa vào RAM
	 fscanf(f...)
	 fgets(f...) //đọc nguyên một câu - kết thúc bằng enter

+ WRITE: fputc(kí tự, f) -> Kí tự được ghi vào đĩa.
	 fprintf(f...)
	 fputs(f...) //ghi nguyên 1 câu vào file

* Tập tin NHỊ PHÂN - BINARY FILE

4. CÁCH LƯU VÀ IN RA MÀN HÌNH 1 DOCUMENT 

void saveADocument() {
	
	char ch; //đón từng kí tự từ bàn phím
	
	FILE* f = fopen("don-doi-nganh.txt", "w"); //a cx dc
	printf("You are required to input a document. Ctrl-S to stop & save your work\n");
	do {
		ch = getchar(); //cứ gõ, ko cần nhấn enter
		//có được kí tự rồi, đẩy ra tập tin ngay
		//fprintf(f, "%c", ch);
		fputc(ch, f); //y chang lệnh fprintf();
		
	} while (ch != 19); //còn chưa gõ tổ hợp Ctrl-S thì cứ gõ nhập tiếp đi			
	
	fclose(f);
	printf("The document is saved successfully\n");
}

void openADocument() {
	char ch;
	FILE* f = fopen("don-doi-nganh.txt", "r");
	do {
		ch = fgetc(f);
		printf("%c", ch);
	} while (ch != EOF);
	
	fclose(f);
}
  
===================================================================================